import { Logger } from '../common/logger';
import { AggregationType } from '../constants/aggregationType';
import { Expression, IQuotes } from './expression';
import { Grouping } from './groupBy';
import { Sorting } from './orderBy';
export declare class Aggregate extends Expression {
    level: number;
    aggregation: AggregationType;
    isPrimalAggregation: boolean;
    arguments: Expression[];
    groupIds: string[];
    grouping: Grouping;
    sorting: Sorting;
    innerExpressions: Aggregate[];
    hasGroupByOver: boolean;
    hasDistinct: boolean;
    constructor(logger: Logger, rawExpression: any, aggregation: AggregationType, queryQuotes: IQuotes, queryExpressions: Expression[], groupId?: string, grouping?: Grouping, level?: number, isPrimalAggregation?: boolean, args?: string[], over?: Grouping, sorting?: Sorting);
    equals(aggregate: Aggregate): boolean;
    isPrimalNonOver(): boolean;
    isPostProcessingType(): boolean;
    getValRef(): string;
    defineInitialProperty(): string;
    distinctProperty(): string;
    defineAggregation(): string;
    definePostProcessing(): string;
    defineSortingComparator(): string;
    defineExpObjRef(): string;
    handleGroupIndex(): void;
    static canHaveSorting(aggrType: string): boolean;
    private fillDefault;
    private parseDistinct;
    private canHaveDistinct;
    private findSibling;
    private handleIndex;
    private matchSorting;
    private hasExtendedSorting;
    private countByAll;
    private defineInitVal;
    private defineAggregationWithSorting;
    private defineSorting;
    private getFirstArgument;
}
