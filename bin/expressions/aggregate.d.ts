import { Logger } from '../common/logger';
import { AggregationType } from '../constants/aggregationType';
import { Expression, IQuotes } from './expression';
import { Grouping } from './groupBy';
import { Sorting } from './orderBy';
export declare class Aggregate extends Expression {
    level: number;
    aggregation: AggregationType;
    isPrimalAggregation: boolean;
    arguments: Expression[];
    groupIds: string[];
    grouping: Grouping;
    sorting: Sorting;
    innerExpressions: Aggregate[];
    hasGroupByOver: boolean;
    hasDistinct: boolean;
    constructor(logger: Logger, rawExpression: any, aggregation: AggregationType, queryQuotes: IQuotes, queryExpressions: Expression[], groupId?: string, grouping?: Grouping, level?: number, isPrimalAggregation?: boolean, args?: string[], over?: Grouping, sorting?: Sorting);
    equals(aggregate: Aggregate): boolean;
    isPrimalNonOver(): boolean;
    isPostProcessingType(): boolean;
    getValRef(): string;
    defineInitialProperty(): string;
    distinctProperty(): string;
    defineAggregation(): string;
    definePostProcessing(): string;
    defineSortingComparator(): string;
    defineExpObjRef(): string;
    handleGroupIndex(): void;
    static canHaveSorting(aggrType: string): boolean;
    private fillDefault();
    private parseDistinct(logger);
    private canHaveDistinct();
    private findSibling(queryExpressions);
    private handleIndex();
    private matchSorting();
    private hasExtendedSorting();
    private countByAll();
    private defineInitVal();
    private defineAggregationWithSorting(expObjDef);
    private defineSorting();
    private getFirstArgument();
}
