import { BaseQuery } from './basePrototypes/baseQuery';
import { IConfig } from './types/iConfig';
import { IQuery } from './types/iQuery';
export declare class Query<T> extends BaseQuery<Query<T>> implements IQuery<T> {
    _preFilter: string;
    private preFiltering;
    private dataSource;
    private changed;
    private context;
    private logger;
    private debugLevel;
    private groupMap;
    private groupComposition;
    private groupingComposition;
    private allExpressions;
    private quotes;
    private fn;
    private code;
    constructor(config?: IConfig);
    config(config: IConfig): Query<T>;
    addContext(reference: object | Function | string, value?: any): Query<T>;
    removeContext(reference: string | object): Query<T>;
    preFilter(filter?: string): Query<T>;
    preOrderBy(): Query<T>;
    define(): Query<T>;
    select(...args: any[]): Query<T>;
    from(dataSource?: any): Query<T>;
    distinct(apply?: boolean): Query<T>;
    groupBy(rawGrouping?: string | string[]): Query<T>;
    totals(): Query<T>;
    filter(rawFilter?: string): Query<T>;
    orderBy(rawSorting?: string | string[]): Query<T>;
    range(start: number, end?: number): Query<T>;
    clone(): Query<T>;
    toList(): T;
    toObject(): T;
    toValue(): any;
    execute(dataSource?: any): T;
    toString(): string;
    static fromDefinition<T>(definition: string | Object): Query<T>;
    protected encapsulate(): Query<T>;
    private applyChange(applied?);
    private execPreFiltering(data);
    private calculate(data);
    private init();
    private createFn();
    private bindFn();
    private hasQueryGrouping();
    private hasAnyPrimalAggregationNonOver();
    private hasAnySubGroup();
    private hasAnyGroupDistinct(groupComposition?);
    private defineAllDeclaration();
    private defineMainGroupingDeclaration();
    private defineAllVariableDeclarations();
    private defineAggregationIterators();
    private getExpAggregationsByLevels();
    private defineUngroups();
    private getUngroups(groupComposition);
    private defineGroupsPostProcessing(postProcessingLvl);
    private createGroupComposition(group, grouping?, parentGrouping?);
    private parseSelection(selection, groupComposition);
    private handleMeaninglessSelection(msgCode, selection);
    private parseGrouping(rawGrouping, parentGrouping);
    private parseSorting(rawSorting);
    private parseFilter(filter);
    private addFunction(fn);
    private getGroupMap(groupComposition, accumulator);
    private defineNonGroupedPostProcessing();
    private definePlainResultSet();
    private defineGroupedResultSet(parentGroupingComposition, postProcessingLvl, shouldFillResults, groupingIds?);
    private defineResultSet(groupComposition?);
    private defineExpressionsPostProcessing(expressions, processingLvl);
    private defineComparators();
    private compareDataSourceType(dataSource);
    private logExpressions();
    private static defineExpAggregations(expressions);
    private static defineSelection(selector);
}
